### 开头

大家好，今天来介绍一下 range tree，中文名字是 区域树 或者 范围树，但是不是 区间树，区间树 是 interval tree

**因为本身 range tree 的资料比较少，并且感觉应该用也很窄，所以可能更多会横向地和其他类似的数据结构进行一些比较**

<!-- **复杂度要考虑空间和时间两个证明** -->

#### 引入

首先，我们从一个问题出发，一个二维平面上有 n 个点，多组询问，每一次我们给出一个矩形区域，求问矩形区域内点的个数。

#### 换页

解决这个问题的方法很多，如果是二维前缀和，如果我们的横纵坐标都不一样的化，即使离散化处理后，这个方法的空间需求还是很大的。或者是权值线段树和树状数组，KD 树也可以解决，R 树，但是今天，介绍一种新的方法或者说数据结构 range tree

#### 换页

是由两个一维的查询，一个x方向、一个y方向组成的，所以说，我们可以先关注一个方向。先解决一维的区间查询，所以我们下面先介绍一下一维的 range tree

#### 一维 range tree

我们想查找一个区间内有多少点？

#### 换页

比如说，我们现在有有序序列，1 3 4 ... 31

类似于 kd 树的构建过程，每一次选出中位数，然后均分。建好以后，它的树是这个样子。

其中，我们把叶子叫做外部节点，同时，我们的外部节点才是我们一开始的数字，对于每一个节点维护 size，自述中有多少叶子

left 指向左子树 right 指向右子树，s 是包含叶子的集合。

然后当我们想查询 2 和 23 之间有多少个数字？就从根开始，找到第一个数字大小在 [2, 23] 内的节点，这里的话很巧，就是 17，也就是根节点

我们先找到这个 split 分割点，第一个完全在所求区间内部的点，从这个点出发分别向左右往下走，找出这样一个完整的路径。我们可以发现，这条路径上的点的一些子节点，它们就像是悬挂在这个路径上，它们的外部节点的集合正好就是我们呢需要查找的所有满足条件的点，这样我们就找到了所有的区间内部的点。

#### 换页展示一下伪代码

因为我们的高度最高是 log n 的，所以这个路径长度最多大概是 2logn 的，复杂度就是 log 的

下面我们可以推广到二维 range tree

#### 二维 range tree

一维的感觉意义不大，下面我们从一维的基础上推广到二维，其实思路是比较直接的。

就是把每一个树的节点变为一个一维 range tree

首先，对于 x 坐标构建一维的 range tree，我们还是按照之前的步骤来，只不过对于每一个节点，我们新加了一个指针，aux，这个指针指向了一颗由 s 内的外部点按照 y 坐标构成的另一个一维 range tree。感觉就是树套树的思想。

#### 换页

关于构建复杂度，我们构建一个一维的 range tree 的时间复杂度是 $O(n)$ 的，这一个的时间复杂度的递推公式就是 xxx，所以时间复杂度就是 $O(n \log n)$ 的

#### 换页

下面介绍查询，如果我们想查找一个矩形区域内部的点的个数，比如说 $[4, 19] \times [y_1, y_2]$

我们还是分解查询，先 x 后 y，这里的 $v_{split}$ 就是 14，然后找出这一个路径，对于路径上的每一个点，我们再去查询它悬挂的点的 y 方向的 range tree

#### 换页复杂度分析

复杂度分析，虽然这样直观想的话感觉不太严谨，但是即使是精确计算一下，复杂度也确实就是 $\log^{2} n $ 的。然后同时，如果是 KD 树来查询，复杂度是 $\sqrt{n}$ 的。

#### 我自己的看法

其实感觉 range tree 很像线段树，它每一次都是选取中位数划分，这很像线段树的划分方式，只不过是在 mid 的外层套上了一层有序数组

同时，在网络上我了解到确实有一部分人就把二维线段树称为 二维 range tree

#### 更高维度的 range tree

就是再多套上几层 range tree

复杂度，说一下 PPT 上面的式子就可以了

#### 优化 

我们可以使用一种叫做 分散层叠 方法来优化这个过程。

我们可以先使用别的问题来解释这一个想法。现在有一些集合，长度 S_1 的长度是 n，并且后一个都是前一个的子集

然后我们这样展示这些数列，上面的每一层都有一个指针，指向下一层的节点，这个节点是它的后继，这样我们就只需要二分一次，然后一直顺着这个指针，就可以找到所有数列中 x 的后继了。

#### 换页

放到 range tree 上就是，对于最后一个维度的查询，我们可以构造出一个这样的各自有序的数列集合。

#### 换页

结果说明

#### 退化情况

其实就是构造一种全序结构，本质就是约靠近左下的方向越小

### 重看 kd 树

我们看二维的这两个树，他们其实是在不同的视角进行划分。kd 树是一个x方向，一个y方向，而 range tree 是x方向狗i按，后每一个节点都是y方向的树。

对于这个矩形内的区域，当kd树划分的区域完全包含在所给区域内部的时候，直接计算。如果不相交，也可以直接忽略，时间复杂度主要是产生在和边界相交的这一部分。

如果我们当前**竖直**划分记为 Q(n)，那么下一个竖直方向的划分就是 Q(n / 4)，所以我们的时间复杂度有：xxx

对于推广到 k 维度，因为一个维度划分以后，剩下的 k-1 维还要都划分一次，才能再次回到当前的维度，所以时间复杂度的递推式子就有：xxx

这里的推导可以使用主定理的结论或者是使用数列的知识。

#### 空间和时间复杂度的比较

我们可以发现，查询 k 维空间内一个区域内点的个数的时候，range tree 是要比 kd 数时间优一些的，但是占用的空间可能会大一些。

可以看到，range tree 对于维数变多的情况下，仍然有着比较优的时间复杂度。而 kd 树在维数变高的情况下，会越来越多接近暴力算法。虽然这只是最坏时间复杂度。

#### 相同点和不同点

其实从它们的相同点和不同点来看，上面的区别也是可以预见的，因为 range tree 是专门解决范围查询类型问题的数据结构，KD 树更经常用于查询最近点。同时它们两个都是静态的，也就是一般来说，我们构建好树以后，不会再去添加或者删除节点，虽然 KD 树有替罪羊重构可以支持添加和删除，但是好像也不是很常用？如果是动态的，我们经常使用 R 树，我了解到好像即使是处理范围类型的问题，好像实际是使用 R 树更多，range tree 也比较少使用，可能这也是为什么 range tree 看起来时间复杂度挺优秀的，但是很少使用的一个原因吧。

### 应用

只能比较浅的泛泛说一些应用，因为对于这个领域确实不是很了解。

数据库查询，每一个限制条件就是一个维度，其实就是一个多维度的查询

计算几何中的一些应用。