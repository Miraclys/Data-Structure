### 开头

大家好，今天来介绍一下 range tree


**因为本身 range tree 的资料比较少，并且感觉应该用也很窄，所以可能更多会横向地和其他类似的数据结构进行一些比较**

**复杂度要考虑空间和时间两个证明**

### 引入

首先，我们从一个问题出发，一个二维平面上有 n 个点，多组询问，每一次我们给出一个矩形区域，求问矩形区域内点的个数。

这个问题本质上是一个二位偏序问题，我们解决的方法挺多的。比如说二位前缀和，权值线段树、树状数组还有 kd 树。但是它们的空间往往是需求比较大的。

今天我们介绍range tree，可以快速解决这一类区间查询的问题。

这种二维的查询是由两个一维的查询，一个x方向、一个y方向组成的，所以说，我们可以先关注一个方向。先解决一维的区间查询，下面价绍一下一维的 range tree

### 一维 range tree

比如说，我们现在有有序序列，1 3 4 ... 31，我们想查询 2 和 23 之间有多少个数字？

类似于 kd 树的构建过程，或者说一维的 range tree 其实就是一维的 kd 树。

我们把这些数按照 kd 树的方式构建，每一次选出中位数，然后均分。建好以后，它的一个子树是这个样子。

我们把叶子叫做外部节点，对于每一个节点维护 size，自述中有多少叶子

left 指向左子树 right 指向右子树，s 是包含叶子的集合。

我们先找到这个 split 分割点，第一个完全在所求区间内部的点，从这个点出发。。。

因为我们的高度最高是 log n 的，所以这个路径长度最多大概是 2logn 的，复杂度就是 log 的

### 二维 range tree

一维的感觉意义不大，下面我们从一维的基础上推广到二维，其实思路是比较直接的。

就是把每一个树的节点变为一个一维 range tree

对于 x 坐标一维 range tree 的构建，我们还是按照之前的步骤来，只不过对于每一个节点，我们新加了一个指针，aux，这个指针指向了一颗由 s 内的点按照 y 坐标构成的 一维 range tree

复杂度。。。

求解过程解释。。。

算法解释。。。

复杂度对比。。。

### 优化 

### 重看 kd 树

我们看二维的这两个树，他们其实是在不同的视角进行划分。kd 树是一个x方向，一个y方向，而range tree是x方向后每一个节点都是y方向的树。

对于这个矩形内的区域，当kd树划分的区域完全包含在所给区域内部的时候，直接计算。如果不相交，也可以直接忽略，时间复杂度主要是产生在和边界相交的这一部分。

如果我们当前**竖直**划分记为 Q(n)，那么下一个是 。。。

这里的推导可以使用主定理的结论或者是使用数列的知识。

比较一下它们的时间复杂度。

可以看到，range tree 对于维数变多的情况下，仍然有着比较优的时间复杂度。而 kd 树在维数变高的情况下，会越来越多接近暴力算法。虽然这只是最坏时间复杂度。

### 应用

